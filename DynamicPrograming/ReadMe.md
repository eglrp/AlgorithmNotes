### 动态规划

> 英文名：Dynamic Programing  
> 是一种分阶段求解决策问题的数学思想  
> 动态规划算法通常基于一个递推公式及一个或多个初始状态。  
> 当前子问题的解将由上一次子问题的解推出。  
> 使用动态规划来解决问题只需要多项式时间复杂度，因此它比回溯法、暴力法要快很多。

> 动态规划算法解决每一个子问题，仅一次，然后保存子问题的结果，以此来避免对子问题的重复计算。

#### 与贪心法的异同

> 都是采用**分步策略**的方式解决问题  
  贪心算法在求解问题的每一步上根据最优量度标准做出某种决策，用于决策的贪心准则仅依赖于局部的和以前的选择，但不依赖于尚未做出的选择和子问题的解  
  动态规划法每一步依赖于子问题的解，直观上，为了在某一步上做出选择，需要先求解若干子问题，再根据子问题的解做出决策，这就使得动态规划求解问题的方法是**自底向上**的 

#### 基本要素

> 一个最优化多步策略问题是否适合用动态规划求解有两个要素：最优子结构特性和重叠子问题  

> 当一个问题的最优解中包含了子问题的最优解时，则称该问题具有最优子结构特性  

> 分治法将问题分成若干相互独立的子问题，但一个问题分解所得的子问题并不总是完全相互独立的，它们可能共享更小的子问题，被称为重叠子问题

#### 动态规划解题步骤

- 问题抽象化
- 建立模型
- 寻找约束条件
- 判断是否满足最优性原理
- 寻找大问题与小问题的递推关系式
- 填表
- 寻找解组成

#### 原理
> 动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。  
但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划具有记忆性，通过填写表把所有已经解决的子问题答案记录下来，  
在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，  
用动态规划解决问题和核心就在于填表，表填写完毕，最优解也找到了

#### 简单理解

  动态规划

- 可分为多个子问题
- 子问题的解被重复使用
- 子问题只求解一次，结果保存在表中，以后用到时直接读取


#### 算法示例

- [01背包问题](/DynamicPrograming/01bag.md)
	> 有n个物品，它们具有各自的重量和价值，现有给定容量的背包  
	  如何让背包里装入的物品具有最大的价值？

- [爬楼梯问题](/DynamicPrograming/climb_stairs.md)
	> 有一个n阶楼梯，每次只能走一阶楼梯或两阶楼梯  
	  问爬到第n阶楼梯共有多少种走法？

- [矩阵连乘问题](/DynamicPrograming/matrix_chain_order.md)
	> n 个矩阵相乘，最小化乘法运算次数

- [钢条切割问题](/DynamicPrograming/steel_cut.md)
	> 给定一段长度为n的钢条和一个价格表pi(i=1,2...n)，制定切割方案，使收益最大

- [最长公共子序列](/DynamicPrograming/lcs.md)
	> 给定两个序列X和Y，求它们的最长公共子序列  
	  [POJ1458](http://poj.org/problem?id=1458)

- [最大子矩阵和](/DynamicPrograming/poj1050.md)
	> [POJ1050](http://poj.org/problem?id=1050)

- [最大算式](/DynamicPrograming/max_formula.md)
	> n个1-9的数字，插入k个乘号和n-k-1个加号，求出最大的算式结果

- [最小化所有子序列中最大值的和](/DynamicPrograming/mini_sum.md)
	> 有一长度为N的整数序列，设计一种划分方法，最小化所有子序列中最大值的和

- [对一棵树进行着色](/DynamicPrograming/coloring_tree.md)

- [最大化所有词汇的质量和](/DynamicPrograming/max_words_quality.md)
	> 将一个句子划分为若干词汇，假设可以用一个函数获得任意一词汇的质量，最大化所有词汇的质量和

- [带权活动选择问题](/DynamicPrograming/weighted_activity.md)
	> 在n个活动中选择一些活动，保证任意两个活动不相交，使得所有被选活动的权重和最大

- [最长非降子序列](/DynamicPrograming/lis.md)
	> 求一个序列的最长非降子序列的长度  

- [编辑距离](/DynamicPrograming/edit_distance.md)
	> 求两个字符串，由一个转成另一个所需的最少编辑次数  

- [最大m子段和](/DynamicPrograming/max_m_subarray.md)  
	> 给定n个数，选择m个不相交的子段，使得所有子段和最大

- [有序合并数组](/DynamicPrograming/merge_array.md)
	> 给定n个数，每次只能合并相邻的两个数，合并的代价是两个数之和，两个数合并得到的数为两个数之和，求合并所有数的最小代价

- [修建滑雪道](/DynamicPrograming/ski_trail.md)

- [最小旅行代价](/DynamicPrograming/min_travel_cost.md)

更多示例见: [LeetCodeNotes#dp](https://github.com/xfwangmm/LeetCodeNotes/blob/master/notes/dp.md)
